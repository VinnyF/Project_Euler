import Data.List

--Recursive part of the prime checker
isPrime' :: (Integral a) => a -> a -> Bool
isPrime' x y
    | (fromIntegral y) > sqrt (fromIntegral x) = True
    | x `mod` y == 0 = False
    | otherwise = isPrime' x (y+1)

--Wrapper for the prime checker, getting rid of numbers less than 2, and initializing the recursive part
isPrime :: (Integral a) => a -> Bool
isPrime x
    | x < 2 = False
    | otherwise = isPrime' x 2

--Returns the value for the given formula
quad :: (Integral a) => a -> a -> a -> a
quad n a b = (n^2) + (n*a) + b

--Creates a triple (a,b,x) from (a,b), where x is the number of consecutive primes generated by the "quad" formula
genTrip :: (Int,Int) -> (Int,Int,Int)
genTrip (a,b) = (a,b,x)
    where x = length $ takeWhile isPrime [quad n a b | n <- [0..]]

getSolutions = map genTrip [(a,b) | a <- [-999,-997..999], b <- [-999,-997..999]]

answer = maximumBy (\(a,b,x) (c,d,y) -> compare x y) getSolutions